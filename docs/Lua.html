<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Aleph One Lua Scripters' Guide</title>
<style type="text/css">
      <!-- 
      body {
	  font-family: Verdana, Helvetica, sans-serif;
	  font-size: 9pt;
	  width: 800px;
      }
      a:link {
	  color: #006600;
      }

      a:visited {
	  color: #669966;
      }
      
      a:hover {
	  color: #009900;
      }

      h1 {
	  background-color: #EEEEEE;
	  border: thin solid #999999;
	  padding: 4px;
      }
      h2 {
	  color: #006600;
      }
      dt {
	  color: #006600;
	  margin-top: 4px;
	  margin-bottom: 4px;
      }
      
      div.triggers dt {
	  border-bottom: thin solid;
	  border-color: #006600;
	  padding-bottom: 1px;
      }

      h3 {
	  color: #003300;
	  margin-bottom: 4px;
	  padding-bottom: 1px;
	  border-bottom: thin solid;
      }

      div.tables p {
	  margin: 4px;
      }

      p.note {
	  color: #666666;
	  font-style: italic;
      }

      ul.args {
	  list-style-type: none;
      }

      ul.args li {
	  margin: 10 px;
      }

      span.access {
	  color: #666666;
	  font-style: italic;
      }

-->
      </style>
</head>
<body>
<h1>Table of Contents</h1>
<ol>
<li>
<a href="#general">General</a>
<ol>
<li>
<a href="#what_is_this">What is This?</a>
</li>
<li>
<a href="#running_a_script">Running a Script</a>
</li>
<li>
<a href="#units">Units</a>
</li>
<li>
<a href="#local_player">Local Player</a>
</li>
</ol>
</li>
<li>
<a href="#triggers">Triggers</a>
</li>
<li>
<a href="#tables">Tables</a>
<ol>
<li>
<a href="#Annotations">Annotations</a>
</li>
<li>
<a href="#Cameras">Cameras</a>
</li>
<li>
<a href="#Game">Game</a>
</li>
<li>
<a href="#Items">Items</a>
</li>
<li>
<a href="#Level">Level</a>
</li>
<li>
<a href="#Lights">Lights</a>
</li>
<li>
<a href="#Lines">Lines</a>
</li>
<li>
<a href="#Media">Media</a>
</li>
<li>
<a href="#Monsters">Monsters</a>
</li>
<li>
<a href="#Music">Music</a>
</li>
<li>
<a href="#Platforms">Platforms</a>
</li>
<li>
<a href="#Players">Players</a>
</li>
<li>
<a href="#Polygons">Polygons</a>
</li>
<li>
<a href="#Projectiles">Projectiles</a>
</li>
<li>
<a href="#Scenery">Scenery</a>
</li>
<li>
<a href="#Sides">Sides</a>
</li>
<li>
<a href="#Tags">Tags</a>
</li>
<li>
<a href="#Terminals">Terminals</a>
</li>
</ol>
</li>
<li>
<a href="#example_icon">Example Icon</a>
<ol></ol>
</li>
</ol>
<h1>
<a name="general"></a>General</h1>
<h2>
<a name="what_is_this"></a>What is This?</h2>
	<p>This is a reference for writing Lua scripts to work in Aleph One. It lists every trigger and table available to Lua scripts. It is expected that Lua functionality will grow in Aleph One, and as it does, so will this document. Not everything here is completely documented, and any help fixing that would be appreciated.</p>
	<p>This is not a reference for Lua itself - see lua.org for that.</p>
      <h2>
<a name="running_a_script"></a>Running a Script</h2>
	<p>There are two ways to get a script to run - level specific MML, and selecting a script at the gather network game dialog. To use level specific MML, put the script in a TEXT resource in the map file. Then put in TEXT resource 128 MML telling A1 where to find the script, which in its most basic form is this:</p>
	<pre>
  &lt;marathon_levels&gt;
    &lt;level index="0"&gt;
      &lt;lua resource="1000"/&gt;
    &lt;/level&gt;
  &lt;/marathon_levels&gt;
	</pre>
	<p>By convention we use TEXT resource 1000+x to hold the script for level x, so the first level in the map file (which has level index 0) gets its script in TEXT resource 1000.</p>
	<p>This works fine for single player games. It will also work for multiplayer games, but only if every player has a copy of the map file and selects it in enviroment prefs.</p>
	<p>To use a script via the network game dialog, put then script in a text file. Then, at the gather network game dialog, select "use script", then select your script file.</p>
	<p>When playing network games, even if you are not gathering, it's important not to have a map file with level specific MML selected in your environment prefs, unless it's the map file for the map you are playing. A1 will run the script for that map file, your game will go out of sync, and you'll be unhappy.</p>
      <h2>
<a name="units"></a>Units</h2>
	<p>The unit for distance we use is World Units (WU) These are the same values you'd see in Forge or with F10 location display, and 1/1024 of what A1 uses internally and what you'd see in Pfhorte.</p>
	<p>Units for speed are . . . well let's say they're messy. :)</p>
      <h2>
<a name="local_player"></a>Local Player</h2>
	<p>A few variables are marked "local player." These variables will always do the right thing when written to, but when reading, will only return a useful result if the player they belong to is "local." In net games, there is a separate copy of each Lua script running on each player's computer, and the player is "local" only to his copy of the script.</p>
	<p>So, the only local player variables the script running on player 4's machine will be able to read from are the ones in Players[4]. For his script, the value of Players[1].zoom_active, for example, will return nil. If this confuses you, it might be better to avoid reading from any variable marked "local player."</p>
      <h1>
<a name="triggers"></a>Triggers</h1>
<div class="triggers">
<p>These are functions scripts can define which Aleph One will call at specific times or events.</p>
<dl>
<dt>init(restoring_game)
  </dt>
<dd>
<p class="description">at beginning of level</p>
<ul class="args">
<li>restoring_game: true if restoring from a saved game</li>
</ul>
</dd>
<dt>cleanup()
  </dt>
<dd>
<p class="description">at end of the level</p>
<p class="note">Primarily this is intended as a last chance for changing netgame scores before the postgame carnage report.</p>
</dd>
<dt>idle()
  </dt>
<dd>
<p class="description">at each tick, before physics and such</p>
</dd>
<dt>postidle()
  </dt>
<dd>
<p class="description">at each tick, after physics and such, but before rendering</p>
</dd>
<dt>start_refuel(type, player_index, side_index)
  </dt>
<dd>
<p class="description">whenever a player starts to use a refuel panel</p>
</dd>
<dt>end_refuel(type, player_index, side_index)
  </dt>
<dd>
<p class="description">whenever a player stops using a refuel panel</p>
</dd>
<dt>tag_switch(tag, player)
  </dt>
<dd>
<p class="description">whenever a player uses a tag switch</p>
<p class="note">Not called when a projectile (e.g., fists) toggles a tag switch</p>
</dd>
<dt>light_switch(light, player)
  </dt>
<dd>
<p class="description">whenever a player uses a light switch</p>
<p class="note">Not called when a projectile (e.g., fists) toggles a light switch</p>
</dd>
<dt>platform_switch(platform, player)
  </dt>
<dd>
<p class="description">whenever a player uses a platform switch</p>
<p class="note">Not called when a projectile (e.g., fists) toggles a platform switch</p>
</dd>
<dt>terminal_enter(terminal_id, player)
  </dt>
<dd>
<p class="description">whenever a player starts using a terminal</p>
</dd>
<dt>terminal_exit(terminal_id, player)
  </dt>
<dd>
<p class="description">whenever a player stops using a terminal</p>
</dd>
<dt>pattern_buffer(buffer_id, player)
  </dt>
<dd>
<p class="description">whenever a player uses a pattern buffer</p>
</dd>
<dt>got_item(type, player)
  </dt>
<dd>
<p class="description">whenever a player picks up an item</p>
<p class="note">Also whenever a player gets an item when a script calls .items.add()</p>
</dd>
<dt>light_activated(index)
  </dt>
<dd>
<p class="description">whenever a light is activated or deactivated</p>
</dd>
<dt>platform_activated(index)
  </dt>
<dd>
<p class="description">whenever a platform is activated or deactivated</p>
</dd>
<dt>player_revived(player)
  </dt>
<dd>
<p class="description">whenever a player revives (presumably only happens in a netgame)</p>
</dd>
<dt>player_killed(player, aggressor_player, action, projectile)
  </dt>
<dd>
<p class="description">whenever a player dies</p>
<ul class="args">
<li>aggressor_player: the player who killed player, possibly himself (suicide), or -1 if killed by a non-player</li>
<li>action: there are no mnemonics for this at this time, making its use difficult</li>
<li>projectile: the projectile that delivered the final blow, or -1 if there is no such projectile</li>
</ul>
</dd>
<dt>player_damaged(victim_player_index, aggressor_player_index, aggressor_monster_index, damage_type, damage_amount, projectile)
  </dt>
<dd>
<p class="description">whenever a player has taken damage, but before he dies if applicable. The player's suit energy or oxygen may be negative when this trigger is called; if it still is when the trigger returns, it will be set to 0. The player's suit energy is tested again after this trigger returns, so a script may prevent a player's death
      </p>
<ul class="args">
<li>victim_player_index: -1 if the victim was damaged by a non-player</li>
<li>aggressor_monster_index: -1 if the victim was damaged by neither a player nor a monster</li>
<li>damage_type: one of the Damage Types, e.g. _damage_fusion</li>
<li>damage_amount: the amount recently subtracted from the player. If _damage_oxygen_drain, damage_amount was assessed against player's oxygen; else against player's suit energy</li>
<li>projectile: the projectile that delivered the damage, or -1 if there is no such projectile</li>
</ul>
</dd>
<dt>monster_killed(monster, aggressor_player, projectile)
  </dt>
<dd>
<p class="description">whenever a monster dies</p>
<ul class="args">
<li>aggressor_player: player index of who killed it, or -1 if killed by non-player</li>
<li>projectile: projectile that delivered the final blow, or -1 if there is no such projectile</li>
</ul>
<p class="note">This is called after a monster has taken lethal damage, but before it's removed form the monster list. You can use this to find out when a monster created with new_monster dies, but a monster discovered by select_monster may have already taken lethal damage, so you may need to check for that case when using select_monster.</p>
</dd>
<dt>item_created(item_index)
  </dt>
<dd>
<p class="description">whenever an item is created and placed on the ground (or floating) somewhere</p>
<p class="note">Currently, this does not trigger on initial item placement because the initial item placement is done before Lua becomes initialised.</p>
</dd>
<dt>projectile_detonated(type, owner, polygon, x, y, z)
  </dt>
<dd>
<p class="description">whenever a projectile detonates, after it has done any area of effect damage</p>
</dd>
</dl>
</div>
<h1>
<a name="tables">Tables</a>
</h1>
<div class="tables">
<p>These are tables (technically, userdata) defined in Aleph One which scripts can use to access objects in the game</p>
<p>Each table also has a read-only .index variable that corresponds to the engine's index</p>
<h3>
<a name="Annotations"></a>Annotations</h3>
<dl>
<dt># Annotations</dt>
<dd>
<p class="description">number of map annotations</p>
</dd>
<dt>Annotations()</dt>
<dd>
<p class="description">iterates through all annotations</p>
</dd>
<dt>Annotations.new(polygon, text [, x] [, y])
  </dt>
<dd>
<p class="description">returns a new annotation</p>
</dd>
<dt>Annotations[index]</dt>
<dd>
<dl>
      <dt>
    .polygon</dt>
<dd>
<p class="description">polygon this annotation is associated with</p>
<p class="note">can be nil</p>
<p class="note">an annotation is only shown when its polygon is visible on the overhead map</p>
</dd>
      <dt>
    .text</dt>
<dd>
<p class="description">annotation text (64 characters max)</p>
</dd>
      <dt>
    .x</dt>
<dd>
<p class="description"></p>
</dd>
      <dt>
    .y</dt>
<dd>
<p class="description"></p>
</dd>
    </dl>
</dd>
</dl>
<h3>
<a name="Cameras"></a>Cameras</h3>
<dl>
<dt># Cameras</dt>
<dd>
<p class="description">number of cameras</p>
</dd>
<dt>Cameras()</dt>
<dd>
<p class="description">iterates through all cameras</p>
</dd>
<dt>Cameras[index]</dt>
<dd>
<dl>
      <dt>:activate(player)
  </dt>
<dd>
<p class="description">activate camera for player</p>
</dd>
      <dt>:clear()
  </dt>
<dd>
<p class="description">deletes all path points and angles</p>
</dd>
      <dt>:deactivate()
  </dt>
<dd>
<p class="description">deactivates camera</p>
</dd>
      <dt>.path_angles</dt>
<dd>
<dl>
<dt>.new(yaw, pitch, time)
  </dt>
<dd>
<p class="description">adds a path angle</p>
</dd>
</dl>
</dd>
      <dt>.path_points</dt>
<dd>
<dl>
<dt>.new(x, y, z, polygon, time)
  </dt>
<dd>
<p class="description">adds a path point</p>
</dd>
</dl>
</dd>
    </dl>
</dd>
</dl>
<h3>
<a name="ControlPanelClasses"></a>ControlPanelClasses</h3>
<dl>
<dt>ControlPanelClasses[control_panel_class]</dt>
<dd></dd>
</dl>
<h3>
<a name="ControlPanelTypes"></a>ControlPanelTypes</h3>
<dl>
<dt>ControlPanelTypes[control_panel_type]</dt>
<dd>
      <dt>
    .class<span class="access"> (read-only)</span>
</dt>
<dd>
<p class="description">class of this control panel type</p>
</dd>
    </dd>
</dl>
<h3>
<a name="DamageTypes"></a>DamageTypes</h3>
<dl>
<dt>DamageTypes[damage_type]</dt>
<dd></dd>
</dl>
<h3>
<a name="DifficultyTypes"></a>DifficultyTypes</h3>
<dl>
<dt>DifficultyTypes[difficulty_type]</dt>
<dd></dd>
</dl>
<h3>
<a name="FadeTypes"></a>FadeTypes</h3>
<dl>
<dt>FadeTypes[fade_type]</dt>
<dd></dd>
</dl>
<h3>
<a name="Game"></a>Game</h3>
<dl>
<dd>
      <dt>
    .difficulty<span class="access"> (read-only)</span>
</dt>
<dd>
<p class="description">the difficulty level</p>
</dd>
      <dt>.global_random(n)
  </dt>
<dd>
<p class="description">returns a random number between 0 and n-1 from Aleph One's original random number generator</p>
</dd>
      <dt>
    .kill_limit<span class="access"> (read-only)</span>
</dt>
<dd>
<p class="description">the game kill limit, or 0 if there is none</p>
</dd>
      <dt>.local_random(n)
  </dt>
<dd>
<p class="description">returns a random number between 0 and n-1 from Aleph One's original random number generator</p>
<p class="note">this is a good way to put net games out of sync</p>
</dd>
      <dt>.random(n)
  </dt>
<dd>
<p class="description">returns a random number between 0 and n-1 using a good random number generator</p>
</dd>
      <dt>
    .type<span class="access"> (read-only)</span>
</dt>
<dd>
<p class="description">whether the game is EMFH, KOTH, etc.</p>
</dd>
    </dd>
</dl>
<h3>
<a name="ItemTypes"></a>ItemTypes</h3>
<dl>
<dt>ItemTypes[item_type]</dt>
<dd></dd>
</dl>
<h3>
<a name="Items"></a>Items</h3>
<dl>
<dt># Items</dt>
<dd>
<p class="description">maximum number of map objects</p>
</dd>
<dt>Items()</dt>
<dd>
<p class="description">iterates through all valid items</p>
</dd>
<dt>Items.new(x, y, height, polygon, type)
  </dt>
<dd>
<p class="description">returns a new item</p>
</dd>
<dt>Items[index]</dt>
<dd>
<dl>
      <dt>:delete()
  </dt>
<dd>
<p class="description">removes item from map</p>
</dd>
      <dt>
    .facing</dt>
<dd>
<p class="description">direction item is facing</p>
</dd>
      <dt>
    .polygon<span class="access"> (read-only)</span>
</dt>
<dd>
<p class="description">polygon the item is in</p>
</dd>
      <dt>
    .type<span class="access"> (read-only)</span>
</dt>
<dd>
<p class="description">type of item</p>
</dd>
      <dt>
    .x<span class="access"> (read-only)</span>
</dt>
<dd>
<p class="description"></p>
</dd>
      <dt>
    .y<span class="access"> (read-only)</span>
</dt>
<dd>
<p class="description"></p>
</dd>
      <dt>
    .z<span class="access"> (read-only)</span>
</dt>
<dd>
<p class="description"></p>
</dd>
    </dl>
</dd>
</dl>
<h3>
<a name="Level"></a>Level</h3>
<dl>
<dd>
      <dt>.fog<br>.underwater_fog</dt>
<dd>
<dl>
<dt>
    .active<br>
      .present</dt>
<dd>
<p class="description">whether fog is present</p>
</dd>
<dt>
    .affects_landscapes</dt>
<dd>
<p class="description">whether fog affects landscapes</p>
</dd>
<dt>.color<p class="note">values range from 0.0 to 1.0</p>
</dt>
<dd>
<dl>
<dt>
    .b</dt>
<dd>
<p class="description">blue</p>
</dd>
<dt>
    .g</dt>
<dd>
<p class="description">green</p>
</dd>
<dt>
    .r</dt>
<dd>
<p class="description">red</p>
</dd>
</dl>
</dd>
<dt>
    .depth</dt>
<dd>
<p class="description">fog depth in WU</p>
</dd>
</dl>
</dd>
      <dt>
    .low_gravity<span class="access"> (read-only)</span>
</dt>
<dd>
<p class="description">whether level is low gravity</p>
</dd>
      <dt>
    .magnetic<span class="access"> (read-only)</span>
</dt>
<dd>
<p class="description">whether level is magnetic</p>
</dd>
      <dt>
    .name<span class="access"> (read-only)</span>
</dt>
<dd>
<p class="description">level name</p>
</dd>
      <dt>
    .rebellion<span class="access"> (read-only)</span>
</dt>
<dd>
<p class="description">whether level is rebellion</p>
</dd>
      <dt>
    .vacuum<span class="access"> (read-only)</span>
</dt>
<dd>
<p class="description">whether level is vacuum</p>
</dd>
    </dd>
</dl>
<h3>
<a name="Lights"></a>Lights</h3>
<dl>
<dt># Lights</dt>
<dd>
<p class="description">number of lights in level</p>
</dd>
<dt>Lights()</dt>
<dd>
<p class="description">iterates through all lights in the level</p>
</dd>
<dt>Lights[index]</dt>
<dd>
<dl>
      <dt>
    .active</dt>
<dd>
<p class="description">whether light is active</p>
</dd>
    </dl>
</dd>
</dl>
<h3>
<a name="Lines"></a>Lines</h3>
<dl>
<dt># Lines</dt>
<dd>
<p class="description">number of lines in level</p>
</dd>
<dt>Lines()</dt>
<dd>
<p class="description">iterates through all lines in the level</p>
</dd>
<dt>Lines[index]</dt>
<dd>
<dl>
      <dt>
    .clockwise_polygon<span class="access"> (read-only)</span>
<br>
      .cw_polygon<span class="access"> (read-only)</span>
</dt>
<dd>
<p class="description">polygon on clockwise side of line</p>
</dd>
      <dt>
    .clockwise_side<span class="access"> (read-only)</span>
<br>
      .cw_side<span class="access"> (read-only)</span>
</dt>
<dd>
<p class="description">clockwise side of line</p>
</dd>
      <dt>
    .counterclockwise_polygon<span class="access"> (read-only)</span>
<br>
      .ccw_polygon<span class="access"> (read-only)</span>
</dt>
<dd>
<p class="description">polygon on counterclockwise side of line</p>
</dd>
      <dt>
    .counterclockwise_side<span class="access"> (read-only)</span>
<br>
      .ccw_side<span class="access"> (read-only)</span>
</dt>
<dd>
<p class="description">counterclockwise side of line</p>
</dd>
    </dl>
</dd>
</dl>
<h3>
<a name="Media"></a>Media</h3>
<dl>
<dt># Media</dt>
<dd>
<p class="description">number of media (liquids) on the level</p>
</dd>
<dt>Media()</dt>
<dd>
<p class="description">iterates through all media on the level</p>
</dd>
<dt>Media[index]</dt>
<dd>
<dl>
      <dt>
    .type</dt>
<dd>
<p class="description">type of media</p>
</dd>
    </dl>
</dd>
</dl>
<h3>
<a name="MediaTypes"></a>MediaTypes</h3>
<dl>
<dt>MediaTypes[media_type]</dt>
<dd></dd>
</dl>
<h3>
<a name="MonsterClasses"></a>MonsterClasses</h3>
<dl>
<dt>MonsterClasses[monster_class]</dt>
<dd></dd>
</dl>
<h3>
<a name="MonsterTypes"></a>MonsterTypes</h3>
<dl>
<dt>MonsterTypes[monster_type]</dt>
<dd>
      <dt>
    .class</dt>
<dd>
<p class="description">class of monster type</p>
</dd>
      <dt>
    .enemies[monster_class]
  </dt>
<dd>
<p class="description">whether monster class is an emeny</p>
</dd>
      <dt>
    .friends[monster_class]
  </dt>
<dd>
<p class="description">whether monster class is a friend</p>
</dd>
      <dt>
    .immunities[damage_type]
  </dt>
<dd>
<p class="description">whether monster type is immune to damage type</p>
</dd>
      <dt>
    .item</dt>
<dd>
<p class="description">item the monster drops when it dies</p>
</dd>
      <dt>
    .weaknesses[damage type]
  </dt>
<dd>
<p class="description">whether monster type has a weakness to damage type</p>
</dd>
    </dd>
</dl>
<h3>
<a name="Monsters"></a>Monsters</h3>
<dl>
<dt># Monsters</dt>
<dd>
<p class="description">maximum number of monsters</p>
</dd>
<dt>Monsters()</dt>
<dd>
<p class="description">iterates through all valid monsters (including player monsters)</p>
</dd>
<dt>Monsters.new(x, y, height, polygon, type)
  </dt>
<dd>
<p class="description">returns a new monster</p>
</dd>
<dt>Monsters[index]</dt>
<dd>
<dl>
      <dt>
    .action<span class="access"> (read-only)</span>
</dt>
<dd>
<p class="description">current AI action of the monster</p>
</dd>
      <dt>
    .active</dt>
<dd>
<p class="description">whether monster has been activated</p>
</dd>
      <dt>:attack(target)
  </dt>
<dd>
<p class="description">instructs monster to attack target</p>
</dd>
      <dt>:damage(amount [, type])
  </dt>
<dd>
<p class="description">damages monster</p>
<p class="note">if no type is specified, fist damage is dealt</p>
</dd>
      <dt>
    .facing<br>
      .yaw</dt>
<dd>
<p class="description">direction the monster is facing</p>
</dd>
      <dt>
    .life<br>
      .vitality</dt>
<dd>
<p class="description">the monster's vitality</p>
<p class="note">monsters that haven't spawned or teleported in yet don't have vitality</p>
</dd>
      <dt>
    .mode<span class="access"> (read-only)</span>
</dt>
<dd>
<p class="description">current AI mode of the monster</p>
</dd>
      <dt>:move_by_path(polygon)
  </dt>
<dd>
<p class="description">instructs monster to move to polygon</p>
<p class="note">monsters get distracted easily en route</p>
<p class="note">once it gets there, it probably won't choose to stay</p>
</dd>
      <dt>
    .player<span class="access"> (read-only)</span>
</dt>
<dd>
<p class="description">if monster is a player monster, the player; otherwise, nil</p>
</dd>
      <dt>:position(x, y, z, polygon)
  </dt>
<dd>
<p class="description">sets position of monster</p>
</dd>
      <dt>
    .type<span class="access"> (read-only)</span>
</dt>
<dd>
<p class="description">type of monster</p>
</dd>
      <dt>
    .valid<span class="access"> (read-only)</span>
</dt>
<dd>
<p class="description">whether monster is still valid</p>
</dd>
      <dt>
    .visible<span class="access"> (read-only)</span>
</dt>
<dd>
<p class="description">whether monster is visible (e.g. has teleported in)</p>
<p class="note">this has nothing to do with whether monsters are cloaked (like invisible S'pht) or not</p>
</dd>
      <dt>
    .x<span class="access"> (read-only)</span>
</dt>
<dd>
<p class="description"></p>
</dd>
      <dt>
    .y<span class="access"> (read-only)</span>
</dt>
<dd>
<p class="description"></p>
</dd>
      <dt>
    .z<span class="access"> (read-only)</span>
</dt>
<dd>
<p class="description"></p>
</dd>
    </dl>
</dd>
</dl>
<h3>
<a name="Music"></a>Music</h3>
<dl>
<dd>
      <dt>.clear()
  </dt>
<dd>
<p class="description">clears the level playlist</p>
</dd>
      <dt>.fade(duration)
  </dt>
<dd>
<p class="description">fades out the currently playing track and clears the playlist</p>
</dd>
      <dt>.play(track1 [, track2] [, ...])
  </dt>
<dd>
<p class="description">appends all of the specified tracks to the end of the playlist</p>
</dd>
      <dt>.stop()
  </dt>
<dd>
<p class="description">stops level music and clears the playlist</p>
</dd>
    </dd>
</dl>
<h3>
<a name="Platforms"></a>Platforms</h3>
<dl>
<dt># Platforms</dt>
<dd>
<p class="description">number of platforms on the level</p>
</dd>
<dt>Platforms()</dt>
<dd>
<p class="description">iterates through all platforms in the level</p>
</dd>
<dt>Platforms[index]</dt>
<dd>
<dl>
      <dt>
    .active</dt>
<dd>
<p class="description">whether platform is currently active</p>
</dd>
      <dt>
    .ceiling_height</dt>
<dd>
<p class="description">current ceiling height of platform</p>
</dd>
      <dt>
    .contracting</dt>
<dd>
<p class="description">direction platform is moving or will move when active</p>
</dd>
      <dt>
    .extending</dt>
<dd>
<p class="description">direction platform is moving or will move when active</p>
</dd>
      <dt>
    .floor_height</dt>
<dd>
<p class="description">current floor height of platform</p>
</dd>
      <dt>
    .monster_controllable</dt>
<dd>
<p class="description">whether platform can be controlled by monsters</p>
</dd>
      <dt>
    .player_controllable</dt>
<dd>
<p class="description">whether platform can be controlled by players</p>
</dd>
      <dt>
    .polygon<span class="access"> (read-only)</span>
</dt>
<dd>
<p class="description">polygon of this platform</p>
</dd>
      <dt>
    .speed</dt>
<dd>
<p class="description">platform speed</p>
</dd>
    </dl>
</dd>
</dl>
<h3>
<a name="Players"></a>Players</h3>
<dl>
<dt># Players</dt>
<dd>
<p class="description">number of players in the game</p>
</dd>
<dt>Players()</dt>
<dd>
<p class="description">iterates through all players in the game</p>
</dd>
<dt>Players[index]</dt>
<dd>
<dl>
      <dt>:accelerate(direction, velocity, vertical_velocity)
  </dt>
<dd>
<p class="description">accelerates player</p>
</dd>
      <dt>.action_flags<p class="note">only valid when read/written in idle()</p>
<p class="note">disabled when the player is viewing a terminal</p>
<p class="note">latched action flags are only true the first tick the key is held down</p>
</dt>
<dd>
<dl>
<dt>
    .action_trigger</dt>
<dd>
<p class="description">respawns, or activates platforms/doors/control panels</p>
<p class="note">latched</p>
</dd>
<dt>
    .cycle_weapons_backward</dt>
<dd>
<p class="description">switches to previous weapon</p>
<p class="note">latched</p>
</dd>
<dt>
    .cycle_weapons_forward</dt>
<dd>
<p class="description">switches to next weapon</p>
<p class="note">latched</p>
</dd>
<dt>
    .left_trigger</dt>
<dd>
<p class="description">fires primary trigger</p>
</dd>
<dt>
    .microphone_button</dt>
<dd>
<p class="description">activates the net mic</p>
<p class="note">can not be set to true; can be set to false</p>
</dd>
<dt>
    .right_trigger</dt>
<dd>
<p class="description">fires secondary trigger</p>
</dd>
<dt>
    .toggle_map</dt>
<dd>
<p class="description">toggles the overhead map</p>
<p class="note">latched</p>
</dd>
</dl>
</dd>
      <dt>:activate_terminal(terminal)
  </dt>
<dd>
<p class="description">activates terminal</p>
</dd>
      <dt>
    .color</dt>
<dd>
<p class="description">color of player (shirt color, if teams are enabled)</p>
</dd>
      <dt>.compass</dt>
<dd>
<dl>
<dt>.all_off()
  </dt>
<dd>
<p class="description">turns all compass quadrants off, disables beacon</p>
</dd>
<dt>.all_on()
  </dt>
<dd>
<p class="description">turns all compass quadrants on, disables beacon</p>
</dd>
<dt>
    .beacon</dt>
<dd>
<p class="description">whether to use the beacon</p>
</dd>
<dt>
    .lua</dt>
<dd>
<p class="description">whether Lua is controlling the compass</p>
</dd>
<dt>
    .ne<br>
      .northeast</dt>
<dd>
<p class="description">whether north east compass quadrant is active</p>
</dd>
<dt>
    .nw<br>
      .northwest</dt>
<dd>
<p class="description">whether north west compass quadrant is active</p>
</dd>
<dt>
    .se<br>
      .southeast</dt>
<dd>
<p class="description">whether south east compass quadrant is active</p>
</dd>
<dt>
    .sw<br>
      .southwest</dt>
<dd>
<p class="description">whether south west compass quadrant is active</p>
</dd>
<dt>
    .x</dt>
<dd>
<p class="description">beacon location</p>
</dd>
<dt>
    .y</dt>
<dd>
<p class="description">beacon location</p>
</dd>
</dl>
</dd>
      <dt>.crosshairs</dt>
<dd>
<dl>
<dt>
    .active<span class="access"> (local player)</span>
</dt>
<dd>
<p class="description">whether crosshairs are visible</p>
<p class="note">if you wish to stop the user from toggling the crosshairs, you must set the state every tick</p>
</dd>
</dl>
</dd>
      <dt>:damage(amount [, type])
  </dt>
<dd>
<p class="description">inflicts damage on player</p>
<ul class="args">
<li>type: if unspecified, crush damage is delt</li>
</ul>
</dd>
      <dt>
    .dead<span class="access"> (read-only)</span>
</dt>
<dd>
<p class="description">whether player is dead</p>
</dd>
      <dt>
    .deaths</dt>
<dd>
<p class="description">deaths not caused by players</p>
</dd>
      <dt>
    .direction<br>
      .yaw</dt>
<dd>
<p class="description">direction player is facing</p>
</dd>
      <dt>
    .energy<br>
      .life</dt>
<dd>
<p class="description">amount of suit energy player has (150 is normal red health)</p>
</dd>
      <dt>
    .elevation<br>
      .pitch</dt>
<dd>
<p class="description">angle player is looking up or down</p>
</dd>
      <dt>.external_velocity</dt>
<dd>
<dl>
<dt>
    .i<br>
      .x</dt>
<dd>
<p class="description"></p>
</dd>
<dt>
    .j<br>
      .y</dt>
<dd>
<p class="description"></p>
</dd>
<dt>
    .k<br>
      .z</dt>
<dd>
<p class="description"></p>
</dd>
</dl>
</dd>
      <dt>
    .extravision_duration</dt>
<dd>
<p class="description">extravision time remaining</p>
</dd>
      <dt>
    .feet_below_media<span class="access"> (read-only)</span>
</dt>
<dd>
<p class="description">whether player is standing in liquid</p>
</dd>
      <dt>:fade_screen(type)
  </dt>
<dd>
<p class="description">fades player's screen</p>
</dd>
      <dt>:find_action_key_target()
  </dt>
<dd>
<p class="description">if player is in range of a platform or control panel, returns a platform or side; otherwise returns nil</p>
<p class="note">you can check the type of the return with is_polygon() and is_side()</p>
</dd>
      <dt>
    .head_below_media<span class="access"> (read-only)</span>
</dt>
<dd>
<p class="description">whether player is completely below liquid</p>
</dd>
      <dt>
    .infravision_duration</dt>
<dd>
<p class="description">infravision time remaining</p>
</dd>
      <dt>.internal_velocity</dt>
<dd>
<dl>
<dt>
    .forward<span class="access"> (read-only)</span>
</dt>
<dd>
<p class="description">player's forward velocity</p>
</dd>
<dt>
    .perpendicular<span class="access"> (read-only)</span>
</dt>
<dd>
<p class="description">player's perpendicular (sidestep) velocity</p>
</dd>
</dl>
</dd>
      <dt>
    .invincibility_duration</dt>
<dd>
<p class="description">invincibility time remaining</p>
</dd>
      <dt>
    .invisibility_duration</dt>
<dd>
<p class="description">invisibility time remaining</p>
<p class="note">player will become subtly invisible if this is set higher than the standard invisibility duration (70 seconds)</p>
</dd>
      <dt>
    .local_<span class="access"> (read-only)</span>
</dt>
<dd>
<p class="description">true if this player is the local player</p>
<p class="note">normally, you shouldn't need this--you'll just make the game go out of sync</p>
</dd>
      <dt>
    .kills[slain_player]
  </dt>
<dd>
<p class="description">kill count against slain_player</p>
</dd>
      <dt>
    .monster<span class="access"> (read-only)</span>
</dt>
<dd>
<p class="description">monster that corresponds to player</p>
</dd>
      <dt>
    .motion_sensor_active<span class="access"> (local player)</span>
</dt>
<dd>
<p class="description">whether player can view his motion sensor</p>
<p class="note">currently, this also controls compass visibility</p>
</dd>
      <dt>
    .name<span class="access"> (read-only)</span>
</dt>
<dd>
<p class="description">player's name</p>
</dd>
      <dt>
    .oxygen</dt>
<dd>
<p class="description">amount of oxygen player has (max is 10800)</p>
</dd>
      <dt>
    .overlays[n]
  </dt>
<dd>
<p class="description">there are 6 overlays, numbered 0 through 5</p>
<dl>
<dt>:clear()
  </dt>
<dd>
<p class="description">turns off overlay</p>
</dd>
<dt>
    .color<span class="access"> (write-only)</span>
</dt>
<dd>
<p class="description">text color</p>
</dd>
<dt>:fill_icon(color)
  </dt>
<dd>
<p class="description">fills icon with solid color</p>
</dd>
<dt>
    .icon<span class="access"> (write-only)</span>
</dt>
<dd>
<p class="description">icon</p>
</dd>
<dt>
    .text<span class="access"> (write-only)</span>
</dt>
<dd>
<p class="description">text</p>
</dd>
</dl>
</dd>
      <dt>:play_sound(sound, pitch)
  </dt>
<dd>
<p class="description">plays sound that only player can hear</p>
</dd>
      <dt>
    .points</dt>
<dd>
<p class="description">how many points player has</p>
</dd>
      <dt>
    .polygon<span class="access"> (read-only)</span>
</dt>
<dd>
<p class="description">polygon the player is standing on</p>
<p class="note">if this gives you trouble, try .monster.polygon</p>
</dd>
      <dt>:position(x, y, z, polygon)
  </dt>
<dd>
<p class="description">set player position</p>
</dd>
      <dt>
    .team</dt>
<dd>
<p class="description">player's team (pants color)</p>
</dd>
      <dt>:teleport(polygon)
  </dt>
<dd>
<p class="description">teleports player to polygon</p>
</dd>
      <dt>:teleport_to_level(level)
  </dt>
<dd>
<p class="description">teleports player to level (of course, all the other players will also go to that level)</p>
</dd>
      <dt>
    .weapons[weapon_type]
  </dt>
<dd>
<dl>
<dt>.primary<br>.secondary</dt>
<dd>
<dl>
<dt>
    .rounds<span class="access"> (read-only)</span>
</dt>
<dd>
<p class="description">how many rounds are currently loaded into the weapon</p>
</dd>
</dl>
</dd>
<dt>:select()
  </dt>
<dd>
<p class="description">attempts to force player to ready weapon</p>
</dd>
</dl>
</dd>
      <dt>
    .weapons.current<span class="access"> (read-only)</span>
</dt>
<dd>
<p class="description">weapon the player is currently wielding</p>
<p class="note">can be nil</p>
</dd>
      <dt>
    .x<span class="access"> (read-only)</span>
</dt>
<dd>
<p class="description"></p>
</dd>
      <dt>
    .y<span class="access"> (read-only)</span>
</dt>
<dd>
<p class="description"></p>
</dd>
      <dt>
    .z<span class="access"> (read-only)</span>
</dt>
<dd>
<p class="description"></p>
</dd>
      <dt>
    .zoom_active<span class="access"> (local player)</span>
</dt>
<dd>
<p class="description">whether player's sniper zoom is active</p>
</dd>
    </dl>
</dd>
</dl>
<h3>
<a name="Polygons"></a>Polygons</h3>
<dl>
<dt># Polygons</dt>
<dd>
<p class="description">number of polygons in the level</p>
</dd>
<dt>Polygons()</dt>
<dd>
<p class="description">iterates through all polygons in the level</p>
</dd>
<dt>Polygons[index]</dt>
<dd>
<dl>
      <dt>.ceiling</dt>
<dd>
<dl>
<dt>
    .height<br>
      .z</dt>
<dd>
<p class="description">ceiling height</p>
</dd>
</dl>
</dd>
      <dt>.floor</dt>
<dd>
<dl>
<dt>
    .height<br>
      .z</dt>
<dd>
<p class="description">floor height</p>
</dd>
</dl>
</dd>
      <dt>
    .media</dt>
<dd>
<p class="description">polygon media (liquid)</p>
</dd>
      <dt>:monsters()
  </dt>
<dd>
<p class="description">iterates through all monsters in this polygon (including player monsters)</p>
</dd>
      <dt>
    .permutation</dt>
<dd>
<p class="description">raw permutation index of this polygon</p>
</dd>
      <dt>
    .type</dt>
<dd>
<p class="description">polygon type</p>
</dd>
      <dt>
    .x<span class="access"> (read-only)</span>
</dt>
<dd>
<p class="description">center of polygon</p>
</dd>
      <dt>
    .y<span class="access"> (read-only)</span>
</dt>
<dd>
<p class="description">center of polygon</p>
</dd>
      <dt>
    .z<span class="access"> (read-only)</span>
</dt>
<dd>
<p class="description">shortcut for .floor.height</p>
</dd>
    </dl>
</dd>
</dl>
<h3>
<a name="ProjectileTypes"></a>ProjectileTypes</h3>
<dl>
<dt>ProjectileTypes[projectile_type]</dt>
<dd></dd>
</dl>
<h3>
<a name="Projectiles"></a>Projectiles</h3>
<dl>
<dt># Projectiles</dt>
<dd>
<p class="description">maximum number of projectiles</p>
</dd>
<dt>Projectiles()</dt>
<dd>
<p class="description">iterates through all valid projectiles</p>
</dd>
<dt>Projectiles.new(x, y, z, polygon, type)
  </dt>
<dd>
<p class="description">returns a new projectile</p>
<p class="note">remember to set the projectile's elevation, facing and owner immediately after you've created it</p>
</dd>
<dt>Projectiles[index]</dt>
<dd>
<dl>
      <dt>
    .damage_scale</dt>
<dd>
<p class="description">amount to scale projectile's normal damage by upon detonating</p>
</dd>
      <dt>
    .dz</dt>
<dd>
<p class="description">instantaneous downward velocity</p>
</dd>
      <dt>
    .elevation<br>
      .pitch</dt>
<dd>
<p class="description">vertical angle</p>
</dd>
      <dt>
    .facing<br>
      .yaw</dt>
<dd>
<p class="description">direction</p>
</dd>
      <dt>:position(x, y, z, polygon)
  </dt>
<dd>
<p class="description">sets projectile position</p>
</dd>
      <dt>
    .owner</dt>
<dd>
<p class="description">monster that fired projectile, or nil</p>
</dd>
      <dt>
    .polygon<span class="access"> (read-only)</span>
</dt>
<dd>
<p class="description">polygon the projectile is in</p>
</dd>
      <dt>
    .type<span class="access"> (read-only)</span>
</dt>
<dd>
<p class="description">type of projectile</p>
</dd>
      <dt>
    .x<span class="access"> (read-only)</span>
</dt>
<dd>
<p class="description"></p>
</dd>
      <dt>
    .y<span class="access"> (read-only)</span>
</dt>
<dd>
<p class="description"></p>
</dd>
      <dt>
    .z<span class="access"> (read-only)</span>
</dt>
<dd>
<p class="description"></p>
</dd>
    </dl>
</dd>
</dl>
<h3>
<a name="Scenery"></a>Scenery</h3>
<dl>
<dt># Scenery</dt>
<dd>
<p class="description">maximum number of map objects</p>
</dd>
<dt>Scenery()</dt>
<dd>
<p class="description">iterates through all valid scenery</p>
</dd>
<dt>Scenery.new(x, y, height, polygon, type)
  </dt>
<dd>
<p class="description">returns a new scenery</p>
</dd>
<dt>Scenery[index]</dt>
<dd>
<dl>
      <dt>:damage()
  </dt>
<dd>
<p class="description">damages scenery</p>
</dd>
      <dt>
    .damaged<span class="access"> (read-only)</span>
</dt>
<dd>
<p class="description">whether this scenery has been damaged</p>
</dd>
      <dt>:delete()
  </dt>
<dd>
<p class="description">removes scenery from the map</p>
</dd>
      <dt>
    .facing</dt>
<dd>
<p class="description">direction scenery is facing</p>
</dd>
      <dt>
    .polygon<span class="access"> (read-only)</span>
</dt>
<dd>
<p class="description">polygon the scenery is in</p>
</dd>
      <dt>
    .solid</dt>
<dd>
<p class="description">whether this scenery is solid</p>
</dd>
      <dt>
    .type<span class="access"> (read-only)</span>
</dt>
<dd>
<p class="description">type of scenery</p>
</dd>
      <dt>
    .x</dt>
<dd>
<p class="description"></p>
</dd>
      <dt>
    .y</dt>
<dd>
<p class="description"></p>
</dd>
      <dt>
    .z</dt>
<dd>
<p class="description"></p>
</dd>
    </dl>
</dd>
</dl>
<h3>
<a name="SceneryTypes"></a>SceneryTypes</h3>
<dl>
<dt>SceneryTypes[scenery_type]</dt>
<dd></dd>
</dl>
<h3>
<a name="Sides"></a>Sides</h3>
<dl>
<dt># Sides</dt>
<dd>
<p class="description">number of sides on the level</p>
</dd>
<dt>Sides()</dt>
<dd>
<p class="description">iterates through all sides on the level</p>
</dd>
<dt>Sides[index]</dt>
<dd>
<dl>
      <dt>.control_panel<p class="note">nil if the side is not a control panel</p>
</dt>
<dd>
<dl>
<dt>
    .permutation</dt>
<dd>
<p class="description">permutation of control panel</p>
</dd>
<dt>
    .type<span class="access"> (read-only)</span>
</dt>
<dd>
<p class="description">type of control panel</p>
</dd>
</dl>
</dd>
      <dt>
    .line<span class="access"> (read-only)</span>
</dt>
<dd>
<p class="description">line this side is attached to</p>
</dd>
      <dt>
    .polygon<span class="access"> (read-only)</span>
</dt>
<dd>
<p class="description">polygon this side is attached to</p>
</dd>
    </dl>
</dd>
</dl>
<h3>
<a name="Tags"></a>Tags</h3>
<dl>
<dt>Tags[index]</dt>
<dd>
<dl>
      <dt>
    .active</dt>
<dd>
<p class="description">tag is active</p>
</dd>
    </dl>
</dd>
</dl>
<h3>
<a name="Terminals"></a>Terminals</h3>
<dl>
<dt># Terminals</dt>
<dd>
<p class="description">number of terminal texts in the level</p>
</dd>
<dt>Terminals()</dt>
<dd>
<p class="description">iterates through all terminal texts on the level</p>
</dd>
<dt>Terminals[index]</dt>
<dd>
<dl>
    </dl>
</dd>
</dl>
<h3>
<a name="WeaponTypes"></a>WeaponTypes</h3>
<dl>
<dt>WeaponTypes[weapon_type]</dt>
<dd></dd>
</dl>
</div>
<h1>
<a name="example_icon"></a>Example Icon</h1>
      <pre>
--[[
This is  an example  of an  icon  in  the format  used by  Aleph One's  overlay
functions.
The first characters  are a digit string  describing the number of  colors. (in
this example, it's 7.
The first character that  is not a digit is ignored,  as are all the characters
following it  that are the same  character. (i.e. I  could use a q instead of a
newline here.
Then,  for  every color,  it reads  a character,  followed by  a six-digit  hex
string,  which is the  HTML-style color corresponding  to that character in the
image.  After reading this string,  it ignores the next character,  whatever it
is.
Once it has  read every color,  it reads all the following characters,  and for
every character it reads for which a color has defined, it puts that color into
the icon as the next pixel. Other characters are ignored. (see below.)
Icons are always 16x16.
]]

[[
7
 0000FF
#000000
.FFFFFF
$7FAE20
%EBD52A
,45983C
*5B4714
*************# The fact
*************# that it
*$$$#*********# ignores
$$$$$#********# characters
$$$$$#$$******# that
$$##$##$$*****# are
$$$$##.#$$#**# not colors
$%%$$#.,#$#**# can be
%%%%%%##,#$$# exploited to interesting
%%%%%%%##$$# effect by a sufficiently
#%%%%%%%$$$$# resourceful and obnoxious
*##%%%%%%$$$$###
#**#%%#%%%###**#
*#*##%%#%%$$$$# person
**#  #%%##%$$# such as
**#   #%%%#%$# myself :)
Additionally, once it has read 256 valid characters, it ignores the rest of the
string.
]]
      </pre>
    </body>
</html>
